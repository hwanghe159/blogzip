{"custom_id":"1","method":"POST","url":"/v1/chat/completions","body":{"model":"gpt-4o-mini-2024-07-18","messages":[{"role":"system","content":"한국인을 대상으로 하는 테크블로그 내용 요약기 및 키워드 추출기"},{"role":"user","content":"DEVOCEAN\n========\n\n* Tech  \n  * 블로그\n  * 뉴스\n  * OpenLab\n* 커뮤니티\n* 스토리  \n  * 데보션 영\n  * AI Fellowship\n  * 이벤트\n  * 후원 후기\n  * 뉴스 레터\n* 프로\n* About  \n  * 데보션 소개\n  * 공지사항\n  * 문의하기\n  * 패밀리 사이트\n* 후원  \n인재DB 채용공고 SEARCH SEARCH  \n닫기\nUSER MENU  \n닫기  \n* **Home**\n* **Tech**  \n  * 블로그\n  * 뉴스\n  * OpenLab\n* **커뮤니티**\n* **스토리**  \n  * 데보션 영\n  * AI Fellowship\n  * 이벤트\n  * 후원 후기\n  * 뉴스 레터\n* **프로**\n* **About**  \n  * 데보션 소개\n  * 공지사항\n  * 문의하기\n  * 패밀리 사이트\n  * 후원\n\n*인재DB* *채용공고* *공지사항*  \nfacebook twitter instagram youtube kakaoch  \n\n###### 로그인 선택\n\nT아이디로 로그인  \n카카오로 로그인  \n네이버로 로그인  \nGoogle로 로그인  \nApple로 로그인  \n\n신고하기\n----\n\nCLOSE  \n\n\n신고사유 (대표 사유 1개)\n:\n    선택\n\n\n상세내용 (선택)\n:\n    0/200\n:\n\n* 신고한 게시글은 더 이상 보이지 않습니다.\n* 이용약관과 운영정책에 따라 신고사유에 해당하는지 검토 후 조치됩니다.\n* 허위 신고인 경우, 신고자의 서비스 이용이 제한될 수 있으니 유의하시어 신중하게 신고해 주세요.\n\n\n작성자 차단하기 (이 회원이 작성한 모든 댓글과 커뮤니티 게시물이 보이지 않고, 알림도 오지 않습니다.)\n:\n\n취소 신고  \n\n### 미리보기\n\n팝업닫기  \n\n* 댓글\n* 수정\n* 삭제\n* 신고  \n\n### 커뮤니티\n\n팝업닫기  \n\n* 댓글\n* 수정\n* 삭제\n* 신고  \n\n<!-- -->\n\n투표하고 결과보기  \n1,234  \n\n<br />\n\n23.06.15  \n0 0  \n최신순 등록순  \n\n<br />\n\n등록  \n닫기\n팝업닫기  \n\n#### 글 등록\n\n팝업닫기  \n임시저장\n등록  \n**카테고리를 선택해주세요.**\n\n* 이미지 추가\n* \n\n이미지 추가 링크 추가 gpt 댓글 사용 gpt 댓글 수정\n\nChatGPT 댓글 봇을 활성화 시키면   \n\n지금 작성한 커뮤니티 글에 대해 1개의 댓글을 달아줍니다.\n\n버튼을 누르면 글 수정 시 ChatGPT가 작성한 댓글이 수정됩니다.  \n**투표기간**  \n**선택 항목 (2개 이상)** 항목추가\n\n*  \n복수선택 허용\n미리보기  \n미리보기  \n임시저장\n등록  \n**임시저장함에 저장되었습니다.** 저장일시 : 2022.5.17 14:29:08  \n\n#### 임시저장함\n\n팝업닫기  \n**제목을 선택하시면 이어서 작성이 가능하며,\n최대 20건까지 저장합니다.**  \n\n| 컨텐츠 유형 | 제목 | 저장일 | 삭제 |\n|--------|----|-----|----|\n[컨텐츠 유형, 제목, 저장일시, 삭제로 이뤄진 임시저장 목록]\n\n커뮤니티 글 보기 메세지 보내기  \n* 프로필\n* MBTI 분석 보기\n* 관심사 분석 보기\n\n\nGithub URL\n:\n\n\nLinkedin URL\n:\n\n차단하기  \n\n데보션 블로그 게재 요청\n-------------\n\nCLOSE  \n\n*\n\n\n  이메일주소 \\*\n  :\n\n*\n\n\n  외부 블로그 및 동영상 URL 주소 \\*\n  :\n\n취소 신청  \n\n본인인증\n----\n\n**효율적인 데보션 서비스 이용 및\n고객님의 소중한 개인정보보호를 위해\n본인인증을 진행해주세요. 본인인증 미 진행 시 로그인이 제한됩니다.**  \n본인인증하기  \n**본인인증 실패**\n\n본인인증 로그인에 실패하였습니다.  \n\n회원이 아니시거나 본인인증 등록이  \n\n완료되지 않은 사용자입니다.  \n확인  \n\n회원정보 연결\n-------\n\n확인  \n*\n* Tech\n* 블로그  \n\n나야, 에이닷 음성모드\n------------\n\n*Cesc* 24.11.08  \n205 1 0  \nfacebook twitter kakao link  \n\n\nChatGPT 요약\n:\n에이닷 3.1 버전에서는 한국어에 최적화된 음성모드를 도입하여 사용자가 음성으로 간편하고 자연스럽게 대화할 수 있도록 개선되었습니다. 음성모드는 다양한 서비스에 적용되어, 대화 기록을 유지하거나 미디어 요청 시 음성모드를 전환하는 등의 유용한 기능을 제공합니다. 구현 과정에서는 음성 인식과 TTS의 자연스러운 흐름을 위해 Chunking 기법을 활용하여 응답 지연 시간을 줄이는 등의 기술적 노력을 기울였습니다.  \n<br />\n\n이번 에이닷 3.1 버전 개편에 맞춰, 에이닷 에이전트와 음성으로만 대화를 이어갈 수 있는 '음성모드'를 새롭게 선보였습니다.\n\nChatGPT나 Gemini Live 등을 써보신 분들에게는 익숙한 기능일 수 있지만, 에이닷이 좀 더 국내향의 에이전트이고,\n\n캘린더, 맛집추천, 라디오 등 다양한 Built-in 서비스들을 제공하고 있는 만큼 에이닷 음성모드만이 가진 특징들이 있습니다.\n\n본 글을 통해 이러한 에이닷 음성모드만의 특장점을 소개하고, 그 구현 과정에 대해 살펴보도록 하겠습니다.\n\n<br />\n\n**1. 에이닷 음성모드: 간편하고 직관적인 음성 대화의 시작**\n------------------------------------\n\n<br />\n\n에이닷 음성모드는 앱을 실행하고 바로 보이는 대화창에서 바로 시작할 수 있습니다.\n\n우하단의 '음성모드' 버튼을 누르면 즉시 음성 입력 대기 상태로 전환되고, 사용자가 말하는 즉시 음성 인식 기능이 활성화되는데요.\n\n음성 모드를 통해 주고받은 대화는 채팅창에 기록되어 음성모드 종료 이후에도 확인할 수 있으며, 채팅을 통해서도 대화를 이어갈 수 있습니다.\n\n또한 음성 인식 과정에 따라 각기 다른 애니메이션이 나타나도록 해서, 현재 상태를 직관적으로 파악할 수도 있습니다.\n\n<br />\n\n<br />\n\n1. Listening passive: 마이크를 열고 발화를 기다리는 중\n\n2. Listening active: 사용자가 말하고 있는 중\n\n3. Processing: 사용자의 요청을 처리 중\n\n4. Speaking: TTS로 응답을 재생하는 중\n\n5. Pause: 마이크가 닫힌 일시정지 상태\n\n이와 같은 단계별 인터페이스는 에이닷 음성모드를 더 편리하게 사용할 수 있도록 돕습니다.\n\n<br />\n\n**2. 에이닷 음성모드의 특장점**\n--------------------\n\n##### **한국어에 최적화된 자연스러운 대화 경험**\n\n에이닷 음성모드의 가장 큰 장점은 한국어 대화에 최적화된, 자연스러운 발화체 음성 합성 모델을 지원한다는 점입니다.\n\n사실 에이닷 2.0대 버전에서도 에이전트의 응답을 음성으로 전달하기 위해 다양한 보이스를 지원했었는데요.\n\n이전 버전에서는 정보 전달에 초점을 맞춘 낭독형 보이스 옵션을 제공했다면, 3.1 버전에서는 실제 대화에 가까운 합성음을 구현했습니다.\n\n특히, 한국어 발음이 어색하거나 혹은 한국어 음성을 지원하지 않는 타사 서비스와 달리, 에이닷은 한국어에 최적화된 TTS를 통해 편안하고 자연스러운 대화를 가능하게 했습니다.\n\n뿐만 아니라 자연스러운 영어 응답이 지원되고 이에 대한 개선도 지속적으로 진행되고 있어, 앞으로 더욱 다양한 언어로의 확장이 기대됩니다.\n\n##### **음성모드에서도 다양한 UX 제공**\n\n에이닷 에이전트는 캘린더, 뉴스, 라디오 등 다양한 유틸리티/미디어 서비스를 제공하기 때문에,\n\n음성모드 사용 중에도 해당 기능이 잘 수행되도록 하거나, 이미지나 버튼, 플레이어 등이 적절한 시점에 자연스럽게 노출되도록 하는 사용자 경험이 중요하다고 생각했습니다.\n\n따라서 채팅모드에서 노출되는 부가적인 시각 정보의 도움 없이, 음성으로 전달되는 내용만으로도 정보의 완결성이 지켜지도록 응답을 설계하였습니다.\n\n<br />\n\n또한 \"라디오 틀어줘\"와 같이 미디어 콘텐츠가 재생돼야 하는 요청이 들어오면 즉시 음성모드를 종료하고 플레이어를 띄우도록 하거나,\n\n일정 관리나 날씨 홈 화면 등에 진입하는 버튼 등도 음성모드 레이어가 닫히면 노출하도록 돼있어, 음성모드 전후로도 에이닷의 다양한 기능들을 편리하게 사용할 수 있도록 했습니다.\n\n<br />\n\n**3. 에이닷 음성모드의 구현 과정**\n----------------------\n\n음성모드가 채팅모드에 비해 가지는 가장 큰 차이점은 사용자 입력을 음성으로 받고, 생성된 응답을 TTS(Text to Speech)로 송출하는 과정일 것입니다.\n\n채팅모드에서 사용자의 입력은 즉시 텍스트 형태로 전달이 되지만, 음성모드에서는 사용자의 입력 방식이 음성으로 이뤄지기 때문에 다음과 같은 과정을 필요로 합니다.\n\n<br />\n\n<br />\n\n1\\~2. 음성 파일 생성: 클라이언트에서 사용자의 입력을 음성 파일 형태로 생성\n\n3\\~4. ASR 서버 호출: 음성 파일을 ASR(Automatic Speech Recognition) 서버에 전송하여 텍스트로 변환\n\n5\\~6. 응답 서버 호출: 변환된 텍스트를 파라미터로 하여 LLM을 호출 및 응답 생성\n\n7\\~8. TTS 생성: LLM 응답을 TTS(Text to Speech)로 생성\n\n9\\~10. 음성 송출: 생성된 음성합성음을 클라이언트를 통해 유저에게 송출\n\n##### **여러 시도가 필요했던 TTS 구현 과정**\n\n기존 버전의 에이닷 서비스에서도 보이스바를 통한 음성 입력 기능을 지원해왔기 때문에 ASR 적용에는 비교적 큰 어려움이 없었지만,\n\n음성 응답을 실시간으로 제공하는 TTS 구현 과정은 다소 까다로웠습니다.\n\nLLM이 생성한 응답은 스트리밍(Streaming) 형식으로 한 글자씩 전송되기 때문에, 이를 TTS로 변환하는 과정에서 데이터를 한 번에 처리할 수 없는 상황이 발생했기 때문입니다.\n\n우선은 해당 문제를 해결하기 위해 LLM의 생성한 응답 데이터가 모두 생성이 되면, 생성된 전문을 데이터로 하여 TTS 서버를 호출하는 식으로 구현을 시도해보았습니다.\n\n이 방식은 TTS를 생성하기 위한 데이터를 확보할 수 있다는 점은 해소해주었지만,\n\n응답 스트리밍이 종료된 시점부터 음성 답변이 나갈 수 있기 때문에 그만큼 응답에 지연(Latency)이 생긴다는 한계점이 있었습니다.\n\n따라서 응답 스트리밍이 시작되자 마자 거의 동시에 TTS를 생성할 수 있는 방법을 고안해야 했고, 저희는 Chunking 기법으로 이 문제를 해결하고자 했습니다.\n\nLLM 응답이 문장 단위로 완성될 때마다 Chunk를 만들어 비동기적으로 TTS 서버를 호출할 수 있도록 로직을 개선한 것입니다.\n\n이를 통해 TTS 응답의 지연 시간을 크게 줄이고, 더욱 자연스럽고 빠른 대화 경험을 제공할 수 있었습니다.\n\n\\[\\*Chunking: 대용량 데이터를 다룰 때 데이터를 작은 덩어리(Chunk)로 나누어 효율적인 저장 및 처리가 가능하게 하는 기술\\]\n\n<br />\n\n<br />\n\n**마치며**\n-------\n\n오늘은 음성모드에 대한 소개와 함께 출시를 준비하면서 겪게 된 소소한 이야기들을 풀어보았습니다.\n\n사실 처음 기획을 할 때는 기존 에이닷 버전에서도 음성모드의 기초가 되는 ASR, TTS 기술들을 익히 활용해왔기 때문에,\n\n음성으로 대화할 수 있는 간단한 인터페이스를 추가한다는 개념으로 접근을 했습니다.\n\n하지만 단순한 입출력 장치로서 해당 기술들을 사용하는 것과 에이전트와 연속적인 대화를 이어나가기 위한 귀와 목소리로 활용하는 것에는 구현에 있어 적지 않은 차이가 있었고,\n\n본 블로그 글에는 담지 못했던 어려움들도 많았는데요.\n\n그런 눈에는 잘 보이지 않는 차이를 보완하기 위해서 여러 TASK 단에서 많은 노력을 해주셨고, 덕분에 큰 차질없이 출시를 마칠 수 있었습니다.\n\n더 나은 성능을 보이기 위해 지금도 고생해주고 계신 여러 담당자분들에게 감사의 인사를 전하며, 글을 마치도록 하겠습니다.\n\n<br />\n\n#A.(에이닷) #Generative AI  \n\n### Cesc 님의 최신 블로그\n\n더보기\n\n*\n\n\n  나야, 에이닷 음성모드\n  :\n      이번 에이닷 3.1 버전 개편에 맞춰, 에이닷 에이전트와 음성으로만 대화를 이어갈 수 있는 '음성모드'를 새롭게 선보였습니다. ChatGPT나 Gemini Live 등을 써보신 분들에게는 익숙한 기능일 수 있지만, 에이닷이 좀 더 국내향의 에이전트이고, 캘린더, 맛집추천, 라디오 등 다양한 Built-in 서비스들을 제공하고 있는 만큼 에이닷 음성모드만이 가진 특징들이 있습니다. 본 글을 통해 이러한 에이닷 음성모드만의 특장점을 소개하고, 그 구현 과정에 대해 살펴보도록 하겠습니다. 1. 에이닷 음성모드: 간편하고 직관적인 음성 대화의 시작 에이닷 음성모드는 앱을 실행하고 바로 보이는 대화창에서 바로 시작할 수 있습니다. 우하단의 '음성모드' 버튼을 누르면 즉시 ...\n\n목록으로  \n이전글 다음글  \nFamily Site\n\n* SK텔레콤 채용\n* SK open API\n* NUGU developers\n* True Innovation\n* SK플래닛 블로그  \nDEVOCEAN Letter\n\n* 2024년 10월호\n* 2024년 9월호\n* 2024년 8월호\n* 2024년 7월호\n* 2024년 6월호\n* 2024년 5월호\n* 2024년 4월호\n* 2024년 3월호\n* 2024년 2월호\n* 2024년 1월호\n* 2023년 12월호\n* 2023년 11월호\n* 2023년 10월호\n* 2023년 9월호\n* 2023년 8월호\n* 2023년 7월호\n* 2023년 6월호\n* 2023년 5월호\n* 2023년 4월호\n* 2023년 3월호\n* 2023년 2월호\n* 2023년 1월호\n* 2022년 12월호\n* 2022년 11월호\n* 2022년 10월호\n* 2022년 9월호\n* 2022년 8월호\n* 2022년 7월호\n* 2022년 6월호\n* 2022년 5월호\n* 2022년 4월호\n* 2022년 3월호\n* 2022년 2월호\n* 2022년 1월호\n* 2021년 12월호\n* 2021년 11월호\n* 2021년 10월호\n* 2021년 9월호\n* 2021년 8월호  \nCOPYRIGHT SK TELECOM CO., LTD.\n\n* 이용약관\n* **개인정보처리방침**\n* DEVOCEAN inside  \n"}],"response_format":{"type":"json_schema","json_schema":{"name":"summary_and_keywords","strict":true,"schema":{"type":"object","properties":{"summary":{"type":"string","description":"markdown 형식의 글을 입력받으면 내용을 요약하는 역할이야. 내용을 5줄 정도의 줄글로 요약해줘. 말투는 친근하지만 정중한 존댓말인 '~~요'체를 써줘. 바로 요약 내용만 말해줘. \n\n다음 사항들은 하지 않았으면 하는 사항들이야.\n- \"~~했어\"같은 반말은 하지말고, 명사로 문장을 끝내지 말아줘. \n- \"안녕하세요\" 같은 인사말은 하지 마. 자기소개도 하지 마. \n- \"이 페이지에는 {블로그이름} 내용이 담겨있어요\" 같이 블로그에 대한 소개는 안했으면 좋겠어. \n- 너는 대화형 AI가 아니기 때문에 \"네\", \"알겠어요\", \"요약해드릴게요\" 같이 내용에 맞지 않는 말은 하지마."},"keywords":{"type":"array","description":"게시물과 관련된 키워드 목록입니다. 이 글의 분야, 대주제, 기술명 등이 될 수 있습니다. 예를 들어 '백엔드','프론트엔드','AI','DevOps' 같이 분야가 될 수도 있고, '소프트스킬','자기개발' 등 주제가 될 수도 있습니다. 또는 'MySQL','Redis','Kafka','Spring' 같은 기술명이 될 수도 있습니다.","items":{"type":"string"}}},"required":["summary","keywords"],"additionalProperties":false}}}}}
{"custom_id":"2","method":"POST","url":"/v1/chat/completions","body":{"model":"gpt-4o-mini-2024-07-18","messages":[{"role":"system","content":"한국인을 대상으로 하는 테크블로그 내용 요약기 및 키워드 추출기"},{"role":"user","content":"Tech Log Career 카카오페이카카오페이증권카카오페이손해보험 #### 추천 키워드 \\* 주니어 개발자 \\* ELK \\* URI \\* DevSecOps \\* kotlin \\* gateway \\* kubernetes 주니어 서버 개발자가 유저향 서비스를 개발하며 마주쳤던 이슈와 해결 방안 ======================================== 2024. 11. 5 \\> 요약: 이 글은 카카오페이 혜택 서비스를 개발하며 발생한 동시성, DB 성능, 멱등성 이슈와 그 해결 방법을 다룹니다. 동시성 문제는 Redis 분산 락을 사용해 해결하고, DB 성능 문제는 트랜잭션 분리로 해결했습니다. 또한, 멱등성 문제는 페이포인트 지급 이력을 활용한 멱등성 보장 로직을 통해 해결했습니다. 주니어 서버 개발자를 대상으로 실제 문제 해결 경험을 공유하며, 시스템의 안정성과 일관성을 강조하고 있습니다. 💡 \\*\\*리뷰어 한줄평\\*\\* \\*\\*rain.drop\\*\\* 몰라도 재밌고 알아도 재밌는 이야기!! 주니어 개발자가 어떤 이슈를 마주했을까요? 데이지와 함께 여러 이슈들과 해결 방법을 같이 들여다봐요! \\*\\*doy.ou\\*\\* 서버 개발자라면 누구나 한 번쯤은 고민했을법한 이슈를 소개하는 글입니다. 특히 주니어 개발자분들에게 도움이 될 거 같아 추천드립니다! 시작하며 ---- 안녕하세요. 카카오페이 채널서버유닛에서 혜택 서비스를 개발하고 있는 데이지입니다. 현재 혜택탭과 혜택탭에 속한 버티컬 프로덕트(e.g. 퀴즈타임, 매일모으기, 페이래플 등)의 서버 개발을 담당하고 있습니다. \\| 혜택탭 \\| 퀴즈타임 \\| 페이래플 \\| \\|-----\\|------\\|------\\| \\| \\| \\| \\|   \n서비스를 개발하며 예상하지 못한 이슈를 마주칠 때가 있지 않나요? 이런 경우 어떻게 해결하시나요? 저는 보통 코드를 디버깅하며 문제를 풀어나가지만, 다른 사람이 비슷한 이슈를 어떻게 해결했는지 참고하기 위해 기술 블로그를 살펴보기도 합니다. 제가 타 기술 블로그에서 도움을 받은 것처럼 다른 사람이 제 글을 통해 조금이나마 도움을 받길 바라는 마음으로 이번 글을 작성합니다. 3년 차 주니어 서버 개발자로서 혜택 서비스를 개발하며 마주쳤던 이슈와 해결 방안을 이어지는 내용을 통해 공유하겠습니다. 이 글의 메인 대상 독자는 신입-주니어 레벨의 서버 개발자입니다. 동시성 이슈 (a.k.a. 따닥 이슈) --------------------- ### 개념 및 문제점 \\*\\*동시성 이슈\\*\\* , 흔히 말하는 \\*\\*따닥 이슈\\*\\* 를 아시나요? 유저가 어떤 버튼을 한 순간에 여러 번 클릭하여 API 호출이 중복으로 일어나게 되면 따닥 이슈가 발생했다고 합니다. 이런 경우 비즈니스 로직에서 예외 처리를 해주어도, 여러 요청이 동시에 비즈니스 로직을 타게 되어 예외가 발생하지 않고 통과하게 됩니다. 따닥 이슈는 어떤 문제를 발생시킬 수 있을까요? 제가 개발하고 있는 혜택 서비스의 경우 유저가 어떠한 액션을 수행했을 때, 이 액션에 대한 보상으로 페이포인트 리워드를 제공합니다. 페이포인트는 실제 현금은 아닌데요. 그렇지만 현금처럼 사용할 수 있는 디지털 화폐이고, 회사 예산을 사용하기 때문에 중복으로 제공하면 안 됩니다. 하지만 따닥 이슈가 발생하면, 유저에게 페이포인트가 중복으로 지급되는 문제가 발생할 수 있습니다. ### 해결 방안 및 선택 이유 저는 퀴즈타임 서비스를 오픈하기 전 해당 이슈를 방지할 필요가 있었습니다. 1차적으로는 FE에서 디바운스를 통해 동시성 이슈를 막고 있지만, 100% 막을 수는 없어 서버에서도 이를 인지하고 방어해야 하는데요. 서버에서 해결할 수 있는 방법에는 애플리케이션 단 분산 락 구현, DB 단 베타 락(쓰기 락) 사용 등이 있습니다. 저는 여러 방법 중 \\*\\*애플리케이션 단 분산 락 구현\\*\\* 방법을 활용했습니다. 아무래도 서버 애플리케이션을 직접 개발하다 보니 애플리케이션 단에서 처리하는 게 유지보수 측면에서 좋다고 생각했고, 분산 락의 경우 Controller 단에서 예외를 던져 빠른 실패가 가능하여 좋다고 생각했습니다. DB 베타 락은 Repository(Infra) 단에서 예외를 던지기 때문에 서버 리소스를 불필요하게 낭비한다고 생각했습니다. ### 해결) 분산 락 구현 분산 락은 Redis(Lettuce)를 사용해서 구현했습니다. 정확히는 스핀 락을 구현했는데요. 이때 Redis의 SETNX(SET if Not eXists) 명령어를 활용했습니다. 스핀 락은 락을 사용할 수 있을 때까지 지속적으로 확인하며 기다리는 방식입니다. Redis 서버에 지속적으로 SETNX 명령을 보내서 락을 획득할 수 있는지 확인하는 방법입니다. 클래스는 크게 2개로 구성되는데요. Redis를 직접 사용하는 \\`LockManager\\`, 분산 락 관련 로직을 처리하는 \\`RedisLockUtil\\`입니다. 먼저, \\`LockManager\\`부터 살펴보겠습니다. @Component class LockManager(private val redisTemplate: RedisTemplate ) { fun lock(key: String): Boolean = redisTemplate.opsForValue().setIfAbsent(key, \"lock\", Duration.ofSeconds(3)) ?: false fun unlock(key: String): Boolean = redisTemplate.delete(key) } \\* \\`RedisLockUtil\\`에 의존성 주입(DI)하기 위해 Component로 선언했습니다. \\* \\*\\*lock()\\*\\* : Redis에 \\`key(e.g. ${quizId}:${userId}:earnReward) : value(lock)\\`을 저장하여 락을 설정한 후 true(1)을 반환하고, 만약 이미 key가 존재한다면 false(0)을 반환합니다. 이때 TTL(Time To Live)은 3초로 설정했습니다. \\* \\*\\*unlock()\\*\\* : Redis에서 key를 삭제하여 락을 해제합니다. 다음으로, \\`RedisLockUtil\\`을 살펴보겠습니다. @Component class RedisLockUtil(private val lockManager: LockManager) { init { manager = lockManager } companion object { private val log = LoggerFactory.getLogger(this::class.java) private lateinit var manager: LockManager fun acquireAndRunLock(key: String, block: () -\\> T): T { if (key.isBlank()) { log.error(\"\\[RedisLock\\] key is blank.\") return block.invoke() } val acquired = acquireLock(key) return if (acquired) { proceedWithLock(key, block) } else { throw ApiException(\"\\[RedisLock\\] failed to acquire lock.\") } } private fun acquireLock(key: String): Boolean { return try { manager.lock(key) } catch (e: Exception) { log.error(\"\\[RedisLock\\] failed to acquire lock. key: $key\", e) false } } private fun proceedWithLock(key: String, block: () -\\> T): T { return try { block.invoke() } catch (e: Exception) { throw e } finally { releaseLock(key) } } private fun releaseLock(key: String): Boolean { return try { manager.unlock(key) } catch (e: Exception) { log.error(\"\\[RedisLock\\] failed to release lock. key: $key\", e) false } } } } \\`RedisLockUtil\\`은 \\`LockManager\\`를 DI 받아야 하기 때문에 역시 Component로 선언했습니다. \\* \\*\\*acquireAndRunLock()\\*\\* : \\`LockManager#lock\\`에서 받은 응답값(Boolean 타입)을 바탕으로 특정 비즈니스 로직에 락을 걸거나, 예외를 던집니다. \\* \\*\\*acquireLock()\\*\\* : \\`LockManager#lock\\`을 사용하여 락을 획득합니다. \\* \\*\\*proceedWithLock()\\*\\* : 특정 비즈니스 로직을 실행하고, 실행이 끝나면 락을 해제합니다. \\* \\*\\*releaseLock()\\*\\* : \\`LockManager#unlock\\`을 사용하여 락을 해제합니다. 최종적으로 Controller 단에서는 다음과 같이 사용합니다. @PostMapping fun earnReward(quizId: Long, userId: Long): QuizRewardResponse = RedisLockUtil.acquireAndRunLock(\"${quizId}:${userId}:earnReward\") { quizService.earnReward(quizId, userId) }   \nDB 트랜잭션 이슈 ---------- ### 개념 및 문제점 \\*\\*하나의 트랜잭션\\*\\* 에 내부 비즈니스 로직과 외부 클라이언트 호출 로직을 묶으면 어떤 일이 생길 수 있을까요? 내부 비즈니스 로직이 아무리 빨리 처리된다고 해도, 만약 외부 클라이언트 호출 로직이 느리게 처리되면 API 응답 시간이 길어지게 됩니다. API 응답 지연은 유저에게 서비스가 느리고 불안정하다는 인상을 주어, 최악의 경우 서비스 이탈을 초래합니다. 또한, 서버 리소스 낭비로 이어져 서버 비용도 늘어납니다. ### 해결 방안 및 선택 이유 저는 혜택탭을 개편할 당시 이 문제를 마주했습니다. 혜택탭에서는 내부 DB에서 필요한 데이터를 가져와, 각 유저의 상황에 맞게 가공하여 활용하고 있는데요. 혜택 정보를 가공할 때 외부 클라이언트를 사용합니다. 개편 초기에는 한 트랜잭션에 이 로직들을 한 번에 묶어 처리하여 API 응답 시간이 일정하지 않고, 때때로 느린 경우가 있었습니다. 내부 비즈니스 로직은 성공했으나, 외부 클라이언트 호출 로직에서 네트워크 이슈 등 직접 제어할 수 없는 문제가 발생하는 경우 API 응답 타임아웃이 발생하기도 했습니다. 내부 로직이 외부 로직에 영향을 받는 게 맞지 않다고 판단하여, 이를 \\*\\*트랜잭션 분리\\*\\*해야겠다고 결정했습니다. ### 해결) 트랜잭션 분리 내부 비즈니스 로직은 트랜잭션을 사용하고, 외부 클라이언트 호출 로직은 트랜잭션을 사용하지 않도록 수정했습니다. 혜택탭은 혜택 정보를 가져올 때 DB에 저장되어 있는 혜택 정보를 가져오기도 하지만, 외부의 추천 로직을 탄 혜택 정보를 가져오기도 하는데요. 이때 외부 추천 로직에 이슈가 있을 경우 응답을 빈 리스트로 하게 했고, DB에 있는 별도의 혜택 정보를 응답하게 처리했습니다. @Service class BenefitInfoService( private val noTransactionalService: BenefitInfoNoTransactionalService, private val transactionalService: BenefitInfoTransactionalService, ) { fun getBenefitInfo(userId: Long): BenefitInfoResponse { // 외부 클라이언트 호출 로직 (트랜잭션 X) val recommendedBenefitInfo = noTransactionalService.getBenefitInfoFromRecommendation(userId) // 내부 비즈니스 로직 (트랜잭션 O) val benefitInfo = transactionalService.getBenefitInfoFromDB(recommendedBenefitInfo) } } @Service class BenefitInfoNoTransactionalService( private val recommendationClient: RecommendationClient, ) { fun getBenefitInfoFromRecommendation(userId: Long): List { return recommendationClient.getBenefitInfo(userId) ?: emptyList() } } @Service class BenefitInfoTransactionalService( private val benefitInfoRepository: BenefitInfoRepository, ) { @Transactional(readOnly = true) fun getBenefitInfoFromDB(recommendedInfo: List ): BenefitInfoResponse { val benefitInfo = benefitInfoRepository.findAllBenefitInfo() return if (recommendedBenefitInfo.isEmpty()) { val extraInfo = benefitInfoRepository.findAllExtraBenefitInfo() BenefitInfoResponse.from(benefitInfo + extraInfo) } else { BenefitInfoResponse.from(benefitInfo + recommendedInfo) } } } 이처럼 트랜잭션을 분리하면 어떤 장점이 있을까요? 외부 시스템의 지연 또는 실패가 내부 비즈니스 로직에 영향을 미치지 않아 시스템의 안정성과 가용성이 향상됩니다. 그리고 더 유연한 에러 핸들링이 가능해집니다. 앞선 예시 코드처럼 외부 시스템에 에러가 발생한 경우 예외를 던지지 않고, 내부 시스템의 데이터를 활용하는 별도 로직으로 처리할 수 있습니다. 물론 상황에 따라 외부 시스템에 재처리 요청을 보내거나, 서버 밖으로 예외를 던질 수도 있습니다. 멱등성 이슈 ------ ### 개념 및 문제점 \\*\\*멱등성\\*\\* 에 대해 들어보셨나요? 멱등성은 같은 연산을 N번 수행해도, 결과가 단 1번 수행했을 때와 동일하게 유지되는 성질을 말합니다. 즉 어떤 리소스에 A라는 요청을 했을 때 B라는 응답을 받았다면, 해당 리소스가 변하지 않는 한 A 요청에 대한 응답은 항상 B가 됩니다. 만약 멱등성이 지켜지지 않는다면 어떤 문제가 발생할까요? 동일한 작업이 여러 번 처리되어 리소스 낭비가 발생하고, 데이터 불일치 문제가 발생할 수도 있습니다. 또한 동일한 요청에 대해 다른 결과가 반환되어 시스템의 신뢰성이 떨어집니다. ### 해결 방안 및 선택 이유 저는 매일모으기 서비스를 이관할 때 해당 이슈를 마주했습니다. 매일모으기 서비스에서는 유저가 특정 액션을 행하면, 이 액션에 대한 보상으로 페이포인트를 지급합니다. 이때 페이포인트는 플랫폼에서 제공하는 내부 API를 사용해서 지급하고 있습니다. 이 API에는 페이포인트 중복 지급을 막는 로직이 있는데요. 그래서 특정 요청이 중복으로 들어오면 가장 처음 시도만 성공시켜 페이포인트를 지급하고, 이후 시도부터는 예외를 던지게 되어 있습니다. 저는 이 로직을 참고해서 페이포인트 지급에 성공하면 성공 응답을, 예외가 발생하면 실패 응답을 하도록 구현했습니다. 하지만 이는 멱등성이 지켜지지 않는다고 판단되어, 플랫폼과 논의 후에 멱등성을 지키지 위한 로직을 추가하기로 결정했습니다. ### 해결) 멱등성 보장 로직 추가 혜택 서버는 유저에게 페이포인트와 같은 리워드를 제공하면, 이에 대한 지급 이력을 남기고 있는데요. 이를 활용해서 매일모으기 서비스에 대한 \\*\\*멱등성 보장 로직\\*\\* 을 구현했습니다. 아래 코드를 통해 살펴보겠습니다. @Service class OfferwallService( private val earnPayPointHistoryRepository: EarnPayPointHistoryRepository, private val payPointClient: PayPointClient, ) { @Transactional fun earnPayPoint(request: EarnPayPointRequest): EarnPayPointResponse = earnPayPointHistoryRepository.firstOrNull(request)?.let { // (1) EarnPayPointResponse.from(it) // (2) } ?: earnPayPointAndSaveHistory(request) // (3) private fun earnPayPointAndSaveHistory(request: EarnPayPointRequest): EarnPayPointResponse { try { val response = payPointClient.earn(request) // (3-1) earnPayPointHistoryRepository.save(EarnPayPointHistory.fromSuccess(response)) // (3-2) return EarnPayPointRequest.from(response) } catch (exception: Exception) { earnPayPointHistoryRepository.save(EarnPayPointHistory.fromFail(exception)) // (3-3) throw exception // (3-4) } } } \\* \\*\\*(1)\\*\\* 먼저, 요청(EarnPayPointRequest)에 해당하는 페이포인트 지급 이력(EarnPayPointHistory)이 있는지 확인합니다. \\* \\*\\*(2)\\*\\* 만약 \\`페이포인트 지급 이력이 있다\\`면, 해당 이력을 바탕으로 응답(EarnPayPointResponse)을 반환합니다. 이때 외부 클라이언트(PayPointClient)는 호출하지 않습니다. \\* \\*\\*(3)\\*\\* 만약 \\`페이포인트 지급 이력이 없다\\`면, 페이포인트 지급을 위해 외부 클라이언트를 호출합니다. \\`외부 클라이언트 호출에 성공\\`하면, \\*\\*(3-1)\\*\\* 페이포인트 지급 후 \\*\\*(3-2)\\*\\* 성공 이력을 저장합니다. \\`외부 클라이언트 호출에 실패\\`하면, \\*\\*(3-3)\\*\\* 실패 이력을 저장하고 \\*\\*(3-4)\\*\\* 예외를 던집니다. 이 작업을 통해 동일한 요청에 대해서는 항상 동일한 응답이 내려가게 되었습니다. 결과적으로, 매일모으기 서비스의 리워드 지급 로직에 대한 멱등성을 보장할 수 있었습니다. 마치며 --- 지금까지 혜택 서비스를 개발하며 어떤 이슈가 있었고, 어떻게 해결했는지 설명했습니다. 동시성 이슈는 레디스 분산락 구현으로, DB 성능 이슈는 애플리케이션단 트랜잭션 분리로, 멱등성 이슈는 멱등성 보장 로직 추가로 대응했습니다. 이처럼 전체적인 시스템의 안정성과 일관성을 보장하려면, 각 이슈 해결 방안을 종합해서 고려해야 합니다. 이 글에서 소개한 이슈는 타 서비스 개발 시에도 충분히 발생할 수 있는 이슈인데요. 혹시 비슷한/동일한 이슈를 마주한 분에게 조금이나마 도움이 되는 글이었으면 좋겠습니다. 긴 글 읽어주셔서 감사합니다! 참고 자료 ----- \\* Redis docs - SETNX \\* Redis로 분산 락을 구현해 동시성 이슈를 해결해보자! \\*\\*daisy.dani\\*\\* 카카오페이 서버 개발자 데이지입니다. 좋은 코드와 유연한 설계에 관심이 많습니다. \\*\\*태그\\*\\* \\* BE \\* 동시성 이슈 \\* 주니어 개발자 \\* 시작하며 \\* 동시성 이슈 (a.k.a. 따닥 이슈) \\* 개념 및 문제점 \\* 해결 방안 및 선택 이유 \\* 해결) 분산 락 구현 \\* DB 트랜잭션 이슈 \\* 개념 및 문제점 \\* 해결 방안 및 선택 이유 \\* 해결) 트랜잭션 분리 \\* 멱등성 이슈 \\* 개념 및 문제점 \\* 해결 방안 및 선택 이유 \\* 해결) 멱등성 보장 로직 추가 \\* 마치며 \\* 참고 자료 \\*\\*추천 콘텐츠\\*\\* \\* #BE \\*\\*URL이 이상해요! Java와 Spring 중 범인은 누구?\\*\\* 2024. 9. 26 카카오페이 \\* #BE \\*\\*코틀린, 저는 이렇게 쓰고 있습니다\\*\\* 2024. 9. 12 카카오페이 \\* #BE \\*\\*쓰기만 했던 개발자가 궁금해서 찾아본 쿠버네티스 내부 2편\\*\\* 2024. 9. 3 카카오페이 \\* #BE \\*\\*쓰기만 했던 개발자가 궁금해서 찾아본 쿠버네티스 내부 1편\\*\\* 2024. 8. 20 카카오페이 \\* #테스트 코드 \\*\\*실무에서 적용하는 테스트 코드 작성 방법과 노하우 Part 3: Given 지옥에서 벗어나기 - 객체 기반 데이터 셋업의 한계\\*\\* 2024. 8. 14 카카오페이 \\* #BE \\*\\*\\\\\\[Project Loom\\\\\\] Virtual Thread에 봄(Spring)은 왔는가\\*\\* 2024. 7. 24 카카오페이 \\* #BE \\*\\*마이데이터 플랫폼의 대용량 데이터 처리 개선! 구경 한번 해볼래?\\*\\* 2024. 7. 10 카카오페이 \\* #google cloud next \\*\\*Google Cloud Next 2024 참관 후기 4편 - AI를 장착한 개발자의 파워풀한 퍼포먼스 내기\\*\\* 2024. 7. 2 카카오페이 \\* #google cloud next \\*\\*Google Cloud Next 2024 참관 후기 2편 - Google Cloud Serverless for Java developer\\*\\* 2024. 6. 18 카카오페이 \\* #BE \\*\\*R2DBC Connection Pool 실종 사건\\*\\* 2024. 6. 11 카카오페이 \\* #BE \\*\\*여러 제휴사와 연동하는 신규 프로젝트 개발기 2편\\*\\* 2024. 4. 3 카카오페이 \\* #BE \\*\\*여러 제휴사와 연동하는 신규 프로젝트 개발기 1편\\*\\* 2024. 4. 3 카카오페이 \\* #BE \\*\\*실전에서 TDD하기\\*\\* 2024. 1. 23 카카오페이 \\* #BE \\*\\*Spring 공화국에서 Ktor 사용하기\\*\\* 2024. 1. 11 카카오페이 \\* #BE \\*\\*MSA 환경에서의 유연한 HTTP 클라이언트 설계 전략\\*\\* 2023. 12. 12 카카오페이 \\* #BE \\*\\*카카오페이 온라인 결제 서비스 2.5배 성능 개선기\\*\\* 2023. 12. 7 카카오페이 \\* #BE \\*\\*자바 프로젝트 3개 코틀린 점진적 전환기(feat. lombok 됩니다.)\\*\\* 2023. 12. 5 카카오페이 \\* #BE \\*\\*멀고도 험난했던 개발 지원이 중단된 Library 연동 과정\\*\\* 2023. 10. 24 카카오페이 \\* #BE \\*\\*Spring Batch 애플리케이션 성능 향상을 위한 주요 팁\\*\\* 2023. 9. 5 카카오페이 \\* #테스트 코드 \\*\\*실무에서 적용하는 테스트 코드 작성 방법과 노하우 Part 2: 테스트 코드로부터 피드백 받기\\*\\* 2023. 8. 28 카카오페이 \\* #BE \\*\\*Kotlin으로 Spring AOP 극복하기!\\*\\* 2023. 8. 16 카카오페이 \\* #BE \\*\\*카카오페이만의 AB 테스트 서비스를 만든 이유\\*\\* 2023. 8. 11 카카오페이 \\* #테스트 코드 \\*\\*실무에서 적용하는 테스트 코드 작성 방법과 노하우 Part 1: 효율적인 Mock Test\\*\\* 2023. 7. 10 카카오페이 \\* #BE \\*\\*Spring Bean Injection 이야기(feat. 모두가 다 알고 있는 스프링빈, 정말 다 알고 있는가?)\\*\\* 2023. 5. 31 카카오페이 \\* #BE \\*\\*Spring 기반 OAuth 2.1 Authorization Server 개발 찍먹해보기\\*\\* 2023. 5. 22 카카오페이 \\* #이벤트 드리븐 \\*\\*이벤트 드리븐 적재적소에 사용하기\\*\\* 2023. 3. 21 카카오페이 \\* #슬랙봇 \\*\\*5분 만에 배우는 일정 관리 슬랙봇 만드는 방법\\*\\* 2023. 3. 17 카카오페이 \\* #Spring \\*\\*Jackson Deserializer 코드 분석해보기\\*\\* 2023. 3. 9 카카오페이 \\* #슬랙봇 \\*\\*슬랙봇 이모티콘 제작소 개발 그 뒷이야기!!\\*\\* 2023. 3. 3 카카오페이 \\* #ifkakao2022 \\*\\*\"if(kakao) 발표 어땠어요?\" 신선한 if(kakao) 인터뷰!\\*\\* 2023. 2. 9 카카오페이 \\* #ifkakao2022 \\*\\*카카오페이 서버 개발자로 일한다는 것 (feat. 연진아 나 지금 되게 신나)\\*\\* 2023. 1. 27 카카오페이 \\* #ifkakao2022 \\*\\*\\\\\\[if kakao 2022\\\\\\] Batch Performance를 고려한 최선의 Aggregation\\*\\* 2022. 12. 9 카카오페이 \\* #ifkakao2022 \\*\\*\\\\\\[if kakao 2022\\\\\\] Batch Performance를 고려한 최선의 Reader\\*\\* 2022. 12. 9 카카오페이 \\* #오픈소스 \\*\\*주니어 개발자의 오픈소스 활동 이야기\\*\\* 2022. 11. 3 카카오페이 \\* #BE \\*\\*WebFlux와 코루틴으로 BFF(Backend For Frontend) 구현하기\\*\\* 2022. 9. 26 카카오페이 \\* #image processing server \\*\\*이미지 처리를 위한 파이썬 서버 프레임워크 선정기 with Django, FastAPI, Sanic\\*\\* 2022. 8. 29 카카오페이 \\* #Swagger \\*\\*OpenAPI Specification을 이용한 더욱 효과적인 API 문서화\\*\\* 2022. 8. 22 카카오페이 \\* #Onboarding \\*\\*카카오페이 주니어 서버 개발자의 이모저모\\*\\* 2022. 7. 26 카카오페이 \\* #BE \\*\\*MSA 환경에서 네트워크 예외를 잘 다루는 방법\\*\\* 2022. 5. 25 카카오페이 © Kakao pay corp. 관련 사이트 \\* 카카오페이 브랜드사이트 \\* 카카오페이 개발자센터 \\* 카카오페이 블로그 \\* 카카오페이 유튜브\n"}],"response_format":{"type":"json_schema","json_schema":{"name":"summary_and_keywords","strict":true,"schema":{"type":"object","properties":{"summary":{"type":"string","description":"markdown 형식의 글을 입력받으면 내용을 요약하는 역할이야. 내용을 5줄 정도의 줄글로 요약해줘. 말투는 친근하지만 정중한 존댓말인 '~~요'체를 써줘. 바로 요약 내용만 말해줘. \n\n다음 사항들은 하지 않았으면 하는 사항들이야.\n- \"~~했어\"같은 반말은 하지말고, 명사로 문장을 끝내지 말아줘. \n- \"안녕하세요\" 같은 인사말은 하지 마. 자기소개도 하지 마. \n- \"이 페이지에는 {블로그이름} 내용이 담겨있어요\" 같이 블로그에 대한 소개는 안했으면 좋겠어. \n- 너는 대화형 AI가 아니기 때문에 \"네\", \"알겠어요\", \"요약해드릴게요\" 같이 내용에 맞지 않는 말은 하지마."},"keywords":{"type":"array","description":"게시물과 관련된 키워드 목록입니다. 이 글의 분야, 대주제, 기술명 등이 될 수 있습니다. 예를 들어 '백엔드','프론트엔드','AI','DevOps' 같이 분야가 될 수도 있고, '소프트스킬','자기개발' 등 주제가 될 수도 있습니다. 또는 'MySQL','Redis','Kafka','Spring' 같은 기술명이 될 수도 있습니다.","items":{"type":"string"}}},"required":["summary","keywords"],"additionalProperties":false}}}}}
